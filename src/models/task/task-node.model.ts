import { cloneDeep } from 'lodash';
import { ITaskNode } from './task-node.interface';
import { TaskRequest } from './task-request.model';
import { TaskResponse } from './task-response.model';
import { ITask } from './task.interface';
import { Task } from './task.model';

/*
    Failover Node Processing 
    --------------------------------
    isFailoverNode= true will make this node a failover-node and is a child of the node being handled. 
    It will only get parsed if the failover error-criteria if provided is satified

    MULTI-ROW Processing i.e processMany == true
    -----------------------------------------------
    Used for processing multiple results fetched by its immediate parent-node.
    When processMany == true, 
      - multiple intance of the same request will be generated by the associated Task equalling the total #results found in parent-node
      - they will be processed concurrently
      - the results from all separate request (only successfull fetches) would then be reduced back to a single task-reponse

*/
export class TaskNode<T extends Task> implements ITaskNode {
  public task: T;
  protected children: TaskNode<T>[];
  public parent: TaskNode<T> | null;
  public processMany: boolean| false;
  public isFailoverNode: boolean| false;
  public hasFailoverNode: boolean | false;
  public failoverErrorCriteria: string;

  constructor(task: T, failoverNode = false, failoverErrorCriteria = '', processMany = false) {
    this.task = task;
    this.parent = null;
    this.children = [];
    this.isFailoverNode = failoverNode;
    this.failoverErrorCriteria = failoverErrorCriteria;
    this.hasFailoverNode = false;
    this.processMany = processMany;
  }

  addChildNode(child: TaskNode<T>) {
    if (child) {
      child.parent = this;
      if(child.isFailoverNode) {
        this.hasFailoverNode=true;
      }
      this.children.push(child);
    }
  }

  /*
    A failover-node doesn't have access to its parent-node response data since the parent failed for some reason as given
    by the error reason. So, a failover-node request has to be created from the request-data that was used during parent-node 
    request submission.
  */
  allowFailover(): boolean {
    let allowFailover: boolean = false;

    if(this.parent){
      allowFailover = true;
      
      //VERIFY: that, all request params/body for failover endpoint are available
      if(this.task.taskRequest.paramsMap.size>0){
        let parentReqDataTxt: string = JSON.stringify(this.parent.task.taskRequest.gatherRequestDataPayload()).toLowerCase();
        this.task.taskRequest.paramsMap.forEach((objKey: string, srchFor: string) => {
          //console.log('Located[' + objKey + '] inside ' + parentReqDataTxt + ' at position ' + parentReqDataTxt.indexOf(objKey.toLowerCase()));
          allowFailover = allowFailover && parentReqDataTxt.indexOf(objKey.toLowerCase())>-1;
        });
      }

      //VERIFY: that, error critera matches the error-reason for parent-node
      if(this.failoverErrorCriteria && this.failoverErrorCriteria.length>0){
        allowFailover = allowFailover
                      && this.parent.task.taskResponse.errors.filter(err => err === this.failoverErrorCriteria).length>0;
      }
    }

    //All failover nodes will have a parent-node, if not then something is wrong!
    console.log('AllowFailover[' + this.task.key + ']? = ' + allowFailover);
    return allowFailover;
  }

  /*
    Parse out data from parent-node task for setting request parameter[s]/body
  */
  async preProcess(): Promise<ITaskNode> {
    //console.log('preProcess[' + this.task.key + '] ' + this.task.request.url);
    try{
      if (this.parent && this.parent.task) {
        if(this.parent.task.taskResponse.hasData()){
          const pData = 
          Array.isArray(this.parent.task.taskResponse.result) && this.parent.task.taskResponse.result.length > 0 && !this.parent.task.allowMany
          ? this.parent.task.taskResponse.result[0]
          : this.parent.task.taskResponse.result;
          this.task = await this.task.preProcess(cloneDeep(pData), null, this.processMany);
        } else if(this.isFailoverNode) {//applies to failover node
          if(this.parent.task.taskRequest.method === 'POST'){
            this.task = await this.task.preProcess(null, this.parent.task.taskRequest.body, this.processMany);
          } else {
            this.task = await this.task.preProcess(null, Object.fromEntries(this.parent.task.taskRequest.paramsMap), this.processMany);
          }
        }
      } else { //applies to root node 
        this.task = await this.task.preProcess();
      }
      return this;
    } catch(errorTask){
      const errorResponse = errorTask as TaskResponse;
      this.task.taskResponse.errors = errorResponse.errors;
      this.task.taskResponse.status = errorResponse.status;
      return Promise.reject(this);
    }
  }

  async process(): Promise<any> {
    if (this.parent && this.parent.task && this.parent.task.taskResponse.hasData()) {
      const pData =
      Array.isArray(this.parent.task.taskResponse.result) && this.parent.task.taskResponse.result.length > 0 && !this.parent.task.allowMany
          ? this.parent.task.taskResponse.result[0]
          : this.parent.task.taskResponse.result;
          this.task = await this.task.process(cloneDeep(pData), this.processMany);
    } else { //applies to root node 
      this.task = await this.task.process(null, this.processMany);
      /*console.log({process: '[' + this.task.key + '] ' + this.task.taskRequest.url, 
                        'response': this.task.taskResponse, 
                        'hasData': this.task.taskResponse.hasData(),
                        'hasError': this.task.taskResponse.hasError()});*/
    }
    return this;
  }

  async postProcess(): Promise<TaskNode<T>> {
    //console.log('postProcess[' + this.task.key + '] ' + this.task.taskRequest.url);
    if (this.parent && this.parent.task && this.parent.task.taskResponse.hasData()) {
      const pData =
      Array.isArray(this.parent.task.taskResponse.result) && this.parent.task.taskResponse.result.length > 0 && !this.parent.task.allowMany
          ? this.parent.task.taskResponse.result[0]
          : this.parent.task.taskResponse.result;
          this.task = await this.task.postProcess(this.task.taskResponse, cloneDeep(pData), this.processMany);
    } else { //applies to root node 
      this.task = await this.task.postProcess(this.task.taskResponse, null, this.processMany);
    }

    return this;
  }

  /*
    Works like a branch function for failover-node support
    If failover-node processes successfully, it will grab all its parent-node's children to be processed.

    This logic is based on specificity
  */
  fetchChildren(): TaskNode<T>[] {
    //console.log('fetchChildren[' + this.task.key + '] ' + this.task.request.url);
    if(this.task.taskResponse.hasData() && this.isFailoverNode){
      if(this.parent){
        this.parent.children
                  .filter(node => !node.isFailoverNode)
                  .forEach(node => this.addChildNode(node));
      }
      return this.children;
    } else if(this.task.taskResponse.hasData()){
      return this.children.filter(node => !node.isFailoverNode);
    } else if(this.task.taskResponse.hasError() && this.hasFailoverNode){
      return this.children.filter(node => node.isFailoverNode && node.allowFailover());
    } else { //has error
      return [];
    }
  }

}